= How to write your own Logstash {plugintype} plugin

This HOWTO will walk you through the process of developing a new {plugintype}
for Logstash. The workflow has changed as of version 1.5 of Logstash, so you'll
want to follow these new and improved steps to contribute a new plugin!


{introfooter}

Logstash is written in Ruby.  If you are unfamiliar with the Ruby programming
language, an excellent quick-start guide is at
https://www.ruby-lang.org/en/documentation/quickstart/.

== Get started
=== Create a new GitHub repo
As of version 1.5 of Logstash, the code for each plugin lives in its own GitHub
repository. So first, you'll need to create a new repo as a home for your
nascent {plugintype}. When logged into GitHub, click on the "Repositories" tab.
You may see a list of repositories you've forked and/or contributed to, or it
may be blank. Either way, you're fine! Now click on the green "New" button near
the top right of the page.

Choose the following settings on your new repo:

* Repository name should be similar to "logstash-{plugintype}-mypluginname"
* Public or Private - up to you (but will need to be Public to submit as an
  official plugin)
* Click the box "Initialize this repository with a README"

=== Copy the {plugintype} code

==== Clone your forked repo
You'll need to clone the new repo you just created. Use a command something like
this:

[source,sh]
[subs="attributes"]
----------------------------------
git clone git@github.com:myuser/logstash-{plugintype}-mypluginname.git
----------------------------------

==== Clone and copy the example plugin (highly recommended)
At this point, you could build the plugin out entirely on your own.  However,
there's a relatively easy way to import the necessary files and directory
structure.

[source,sh]
[subs="attributes"]
----------------------------------
cd /tmp
git clone git@github.com:logstash-plugins/logstash-{plugintype}-{pluginname}.git
cd logstash-{plugintype}-{pluginname}
rm -rf .git README.md
cp -R * /path/to/logstash-{plugintype}-mypluginname/
----------------------------------

We don't need the `.git` directory or its contents, nor do we need this
`README.md` as we created one when we made our repository in the last step.
Don't forget to clean up the temporary directory after you've copied the
contents.

Your plugin's file structure should look something like this:
[source,sh]
[subs="attributes"]
----------------------------------
$ ls -1
Gemfile
LICENSE
README.md
Rakefile
lib
logstash-{plugintype}-{pluginname}.gemspec
spec
----------------------------------

=== Rename the files
Since we've copied the files from the logstash-{plugintype}-{pluginname}
repository, there are a few files we should rename accordingly.

==== The plugin file
Inside the `lib/logstash/pass:attributes[{plugintype}]s/` directory is the
`pass:attributes[{pluginname}].rb` file.  It should be renamed to match
`mypluginname`, e.g.

[source,sh]
[subs="attributes"]
----------------------------------
cd lib/logstash/{plugintype}s
mv {pluginname}.rb mypluginname.rb
----------------------------------

==== The rspec file
In like fashion, inside the `spec/pass:attributes[{plugintype}]s/` directory is
the `pass:attributes[{pluginname}]_spec.rb` file.  It, too, should be renamed to
match `mypluginname`, e.g.

[source,sh]
[subs="attributes"]
----------------------------------
cd spec/{plugintype}s
mv {pluginname}_spec.rb mypluginname_spec.rb
----------------------------------

==== The gemspec file
The gemspec file also needs to be renamed.

[source,sh]
[subs="attributes"]
----------------------------------
mv logstash-{plugintype}-{pluginname}.gemspec logstash-{plugintype}-mypluginname.gemspec
----------------------------------

==== An overview of your plugin
We'll take a closer look at these details in a bit, but let's see what the full
plugin looks like, first!

[source,sh]
[subs="attributes"]
----------------------------------
vi lib/logstash/{plugintype}s/mypluginname.rb
----------------------------------
Substitute your text editor of choice.

// /////////////////////////////////////////////////////////////////////////////
// Input (conditionally recognized by the presence of the run_method attribute)
// /////////////////////////////////////////////////////////////////////////////
ifdef::run_method[]
[source,ruby]
[subs="attributes"]
----------------------------------
# encoding: utf-8
require "logstash/{plugintype}s/base"
require "logstash/namespace"
require "stud/interval"
require "socket" # for Socket.gethostname

# Generate a repeating message.
#
# This plugin is intented only as an example.

class LogStash::{pluginclass}::{pluginnamecap} < LogStash::{pluginclass}::Base
  config_name "example"

  # If undefined, Logstash will complain, even if codec is unused.
  default :codec, "plain"

  # The message string to use in the event.
  config :message, :validate => :string, :default => "Hello World!"

  # Set how frequently messages should be sent.
  #
  # The default, `1`, means send a message every second.
  config :interval, :validate => :number, :default => 1

  public
  def register
    @host = Socket.gethostname
  end # def register

  def run(queue)
    Stud.interval(@interval) do
      event = LogStash::Event.new("message" => @message, "host" => @host)
      decorate(event)
      queue << event
    end # loop
  end # def run

end # class LogStash::{pluginclass}::{pluginnamecap}
----------------------------------
endif::run_method[]

// /////////////////////////////////////////////////////////////////////////////
// Codec (conditionally recognized by the presence of the encode_method
// attribute)
// /////////////////////////////////////////////////////////////////////////////
ifdef::encode_method[]
[source,ruby]
[subs="attributes"]
----------------------------------
# encoding: utf-8
require "logstash/{plugintype}s/base"
require "logstash/codecs/line"

class LogStash::{pluginclass}::{pluginnamecap} < LogStash::{pluginclass}::Base

  # This example codec will append a string to the message field
  # of an event, either in the decoding or encoding methods
  #
  # This is only intended to be used as an example.
  #
  # input {
  #   stdin { codec => example }
  # }
  #
  # or
  #
  # output {
  #   stdout { codec => example }
  # }
  config_name "example"

  # Append a string to the message
  config :append, :validate => :string, :default => ', Hello World!'

  public
  def register
    @lines = LogStash::Codecs::Line.new
    @lines.charset = "UTF-8"
  end

  public
  def decode(data)
    @lines.decode(data) do |line|
      replace = { "message" => line["message"].to_s + @append }
      yield LogStash::Event.new(replace)
    end
  end # def decode

  public
  def encode(event)
    @on_event.call(event, event["message"].to_s + @append + NL)
  end # def encode

end # class LogStash::{pluginclass}::{pluginnamecap}
----------------------------------
endif::encode_method[]

// /////////////////////////////////////////////////////////////////////////////
// Filter (conditionally recognized by the presence of the filter_method
// attribute)
// /////////////////////////////////////////////////////////////////////////////
ifdef::filter_method[]
[source,ruby]
[subs="attributes"]
----------------------------------
# encoding: utf-8
require "logstash/{plugintype}s/base"
require "logstash/namespace"

# This example filter will replace the contents of the default
# message field with whatever you specify in the configuration.
#
# It is only intended to be used as an example.
class LogStash::{pluginclass}::{pluginnamecap} < LogStash::{pluginclass}::Base

  # Setting the config_name here is required. This is how you
  # configure this {plugintype} from your Logstash config.
  #
  # {plugintype} {
  #   {pluginname} { message => "My message..." }
  # }
  config_name "example"

  # Replace the message with this value.
  config :message, :validate => :string, :default => "Hello World!"


  public
  def register
    # Add instance variables
  end # def register

  public
  def filter(event)

    if @message
      # Replace the event message with our message as configured in the
      # config file.
      event["message"] = @message
    end

    # filter_matched should go in the last line of our successful code
    filter_matched(event)
  end # def {plugintype}

end # class LogStash::{pluginclass}::{pluginnamecap}
----------------------------------
endif::filter_method[]

// /////////////////////////////////////////////////////////////////////////////
// Output (conditionally recognized by the presence of the receive_method
// attribute)
// /////////////////////////////////////////////////////////////////////////////
ifdef::receive_method[]
[source,ruby]
[subs="attributes"]
----------------------------------
# encoding: utf-8
require "logstash/{plugintype}s/base"
require "logstash/namespace"

# An example output that does nothing.
class LogStash::{pluginclass}::{pluginnamecap} < LogStash::{pluginclass}::Base
  config_name "example"

  public
  def register
  end # def register

  public
  def receive(event)
  end # def receive

end # class LogStash::{pluginclass}::{pluginnamecap}
----------------------------------
endif::receive_method[]

=== Anatomy of a {plugintype} plugin

Now let's take a line-by-line look at this new example plugin.

==== The `encoding`

It seems like a small thing, but please don’t omit adding

[source,sh]
----------------------------------
# encoding: utf-8
----------------------------------

to the top of your {plugintype} plugin. Logstash depends on things being in
UTF-8, so we put this here to tell the Ruby interpreter that we’re going to be
using the UTF-8 encoding.

==== `require` Statements

A Logstash {plugintype} plugin requires some parent classes that can be
referenced through the indicated statements. The following require statements
are mandatory:

[source,ruby]
[subs="attributes"]
----------------------------------
require "logstash/{plugintype}s/base"
require "logstash/namespace"
----------------------------------

Of course, the plugin you build may depend on other code, or even gems. Just put
them here along with these Logstash dependencies.

=== Plugin Body

Let's go through the various elements of the plugin itself.

==== `class` Declaration
[source,ruby]
[subs="attributes"]
----------------------------------
class LogStash::{pluginclass}::{pluginnamecap} < LogStash::{pluginclass}::Base
----------------------------------

The class name will need to be a sub-class of
`LogStash::pass:attributes[{pluginclass}]::Base`, and it should extend it as
shown in the line above. You should name your class in a way that closely
mirrors the plugin name, e.g.
`LogStash::pass:attributes[{pluginclass}]::pass:attributes[{pluginnamecap}]` in
this case.

==== The `config_name`
[source,ruby]
[subs="attributes"]
----------------------------------
  config_name "{pluginname}"
----------------------------------
This is the name your plugin will call inside the appropriate block.

For this example, if we set `config_name "pass:attributes[{pluginname}]"` in our
code, the corresponding Logstash configuration block would look like this:

// /////////////////////////////////////////////////////////////////////////////
// If encode_method is NOT defined (i.e. not a codec)
// /////////////////////////////////////////////////////////////////////////////
ifndef::encode_method[]
[source,js]
[subs="attributes"]
----------------------------------
{plugintype} {
  {pluginname} {...}
}
----------------------------------
endif::encode_method[]

// /////////////////////////////////////////////////////////////////////////////
// If encode_method IS defined (i.e. for codecs only)
// /////////////////////////////////////////////////////////////////////////////
ifdef::encode_method[]
[source,js]
[subs="attributes"]
----------------------------------
input {
  codec => {pluginname} {...}
}
----------------------------------

Or if using the codec in an output block:

[source,js]
[subs="attributes"]
----------------------------------
output {
  codec => {pluginname} {...}
}
----------------------------------
endif::encode_method[]

==== Configuration Parameters
[source,ruby]
----------------------------------
  config :variable_name, :validate => :variable_type, :default => "Default value", :required => boolean, :deprecated => boolean
----------------------------------
The configuration, or `config` section allows us to define as many (or as few)
parameters as are needed to enable Logstash to process events.

There are several configuration attributes:

* `:validate` - allows developers to enforce a particular data type is passed to
Logstash for this configuration option, e.g. `string`, `password`, `boolean`,
`integer`, `float`, `array`, `hash`, etc.
* `:default` - lets you specify a default value for a parameter
* `:required` - whether or not this parameter is mandatory (a Boolean `true` or
`false`)
* `:deprecated` - informational (also a Boolean `true` or `false`)

=== Plugin Methods

{methodheader}

// /////////////////////////////////////////////////////////////////////////////
// If register_method is defined (should be all types)
// /////////////////////////////////////////////////////////////////////////////
ifdef::register_method[]
==== The `register` Method
[source,ruby]
[subs="attributes"]
----------------------------------
  public
  def register
  end # def register
----------------------------------

The Logstash `register` method is like an `initialize` method. It was originally
created to enforce having `super` called, preventing headaches for newbies.
(Note: It may go away in favor of `initialize`, in conjunction with some
enforced testing to ensure `super` is called.)

`public` means the method can be called anywhere, not just within the class.
This is the default behavior for methods in Ruby, but it is called explicitly
here anyway.

You may also assign instance variables here (i.e. variables prepended by `@`).
Configuration variables are now in scope as instance variables, e.g.
`@message`

endif::register_method[]

// /////////////////////////////////////////////////////////////////////////////
// If filter_method is defined (should only be for filter plugin page)
// /////////////////////////////////////////////////////////////////////////////
ifdef::filter_method[]
==== The `filter` Method
[source,ruby]
[subs="attributes"]
----------------------------------
  public
  def filter(event)

    if @message
      # Replace the event message with our message as configured in the
      # config file.
      event["message"] = @message
    end

  # filter_matched should go in the last line of our successful code
  filter_matched(event)
end # def filter
----------------------------------
The plugin's `filter` method is where the actual filtering work takes place!
Inside the `filter` method you can refer to the event data using the `event`
hash. Configuration variables are now in scope as instance variables, e.g.
`@message`

[source,ruby]
----------------------------------
  filter_matched(event)
----------------------------------
Calling the `filter_matched` method upon succesful execution of the plugin will
ensure that any fields or tags added through the Logstash configuration for this
filter will be handled correctly. For example, any `add_field`, `remove_field`,
`add_tag` and/or `remove_tag` actions will be performed at this time.

Event methods such as `event.cancel` are now available to control the workflow
of the event being processed.
endif::filter_method[]

// /////////////////////////////////////////////////////////////////////////////
// If decode_method is defined (should only be for codec plugin page)
// /////////////////////////////////////////////////////////////////////////////
ifdef::decode_method[]
==== The `decode` Method
[source,ruby]
[subs="attributes"]
----------------------------------
  public
  def decode(data)
    @lines.decode(data) do |line|
      replace = { "message" => line["message"].to_s + @append }
      yield LogStash::Event.new(replace)
    end
  end # def decode
----------------------------------
The codec's `decode` method is where data coming in from an input is transformed
into an event.  There are complex examples like the
https://github.com/logstash-plugins/logstash-codec-collectd/blob/master/lib/logstash/codecs/collectd.rb#L386-L484[collectd]
codec, and simpler examples like the https://github.com/logstash-plugins/logstash-codec-spool/blob/master/lib/logstash/codecs/spool.rb#L11-L16[spool]
codec.

There must be a `yield` statement as part of the `decode` method which will
return decoded events to the pipeline.
endif::decode_method[]

// /////////////////////////////////////////////////////////////////////////////
// If encode_method is defined (should only be for codec plugin page)
// /////////////////////////////////////////////////////////////////////////////
ifdef::encode_method[]
==== The `encode` Method
[source,ruby]
[subs="attributes"]
----------------------------------
  public
  def encode(event)
    @on_event.call(event, event["message"].to_s + @append + NL)
  end # def encode
----------------------------------
The `encode` method takes an event and serializes it (_encodes_) into another
format.  Good examples of `encode` methods include the simple https://github.com/logstash-plugins/logstash-codec-plain/blob/master/lib/logstash/codecs/plain.rb#L39-L46[plain]
codec, the slightly more involved https://github.com/logstash-plugins/logstash-codec-msgpack/blob/master/lib/logstash/codecs/msgpack.rb#L38-L46[msgpack]
codec, and even an https://github.com/logstash-plugins/logstash-codec-avro/blob/master/lib/logstash/codecs/avro.rb#L38-L45[avro]
codec.

In most cases, your `encode` method should have an `@on_event.call()` statement.
This call will output data per event in the described way.
endif::encode_method[]

// /////////////////////////////////////////////////////////////////////////////
// If run_method is defined (should only be for input plugin page)
// /////////////////////////////////////////////////////////////////////////////
ifdef::run_method[]
==== The `run` Method
The `pass:attributes[{pluginname}]` input plugin has the following `run` Method:
[source,ruby]
[subs="attributes"]
----------------------------------
  def run(queue)
    Stud.interval(@interval) do
      event = LogStash::Event.new("message" => @message, "host" => @host)
      decorate(event)
      queue << event
    end # loop
  end # def run
----------------------------------
The `run` method is where a stream of data from an input becomes an event.

The stream can be plain or generated as with the
https://github.com/logstash-plugins/logstash-input-heartbeat/blob/master/lib/logstash/inputs/heartbeat.rb#L43-L61[heartbeat]
input plugin.  In these cases, though no codec is used,
https://github.com/logstash-plugins/logstash-input-heartbeat/blob/master/lib/logstash/inputs/heartbeat.rb#L17[a default codec]
must be set in the code to avoid errors.

Here's another example `run` method:
[source,ruby]
[subs="attributes"]
----------------------------------
  def run(queue)
    while true
      begin
        # Based on some testing, there is no way to interrupt an IO.sysread nor
        # IO.select call in JRuby.
        data = $stdin.sysread(16384)
        @codec.decode(data) do |event|
          decorate(event)
          event["host"] = @host if !event.include?("host")
          queue << event
        end
      rescue IOError, EOFError, LogStash::ShutdownSignal
        # stdin closed or a requested shutdown
        break
      end
    end # while true
    finished
  end # def run
----------------------------------
In this example, we are sending the `data` to the codec defined in the
configuration to `decode` the data stream and return an event.

In both examples, the resulting `event` is passed to the `decorate` method:
[source,ruby]
[subs="attributes"]
----------------------------------
      decorate(event)
----------------------------------
This applies any tags you might have set in the input configuration block, e.g.
`tags => ["tag1", "tag2"]`.

Also in both examples, the `event`, after being "decorated," is appended to the
queue:
[source,ruby]
[subs="attributes"]
----------------------------------
      queue << event
----------------------------------

This inserts the event into the pipeline.

===== More Examples
Because input plugins can range from simple to complex, it may help to see more
examples of how they have been created:

 - https://github.com/logstash-plugins/logstash-input-syslog/blob/master/lib/logstash/inputs/syslog.rb[syslog]
 - https://github.com/logstash-plugins/logstash-input-zeromq/blob/master/lib/logstash/inputs/zeromq.rb[zeromq]
 - https://github.com/logstash-plugins/logstash-input-stdin/blob/master/lib/logstash/inputs/stdin.rb[stdin]
 - https://github.com/logstash-plugins/logstash-input-tcp/blob/master/lib/logstash/inputs/tcp.rb[tcp]

There are lots more examples in the https://github.com/logstash-plugins?query=logstash-input[logstash-plugin github repository].

endif::run_method[]

// /////////////////////////////////////////////////////////////////////////////
// If receive_method is defined (should only be for output plugin page)
// /////////////////////////////////////////////////////////////////////////////
ifdef::receive_method[]
==== The `receive` Method
[source,ruby]
[subs="attributes"]
----------------------------------
  public
  def receive(event)
  end # def event
----------------------------------
This empty `receive` method does absolutely nothing, which is valid code from
the https://github.com/logstash-plugins/logstash-output-null/blob/master/lib/logstash/outputs/null.rb[null]
output plugin.

The `receive` method _receives_ events from the pipeline and further processes
them before sending them to their final destination.  These destinations can
be as varied as https://github.com/logstash-plugins/logstash-output-file/blob/master/lib/logstash/outputs/file.rb[files],
https://github.com/logstash-plugins/logstash-output-elasticsearch/blob/master/lib/logstash/outputs/elasticsearch.rb[elasticsearch],
https://github.com/logstash-plugins/logstash-output-email/blob/master/lib/logstash/outputs/email.rb[email],
https://github.com/logstash-plugins/logstash-output-rabbitmq/blob/master/lib/logstash/outputs/rabbitmq.rb[RabbitMQ],
https://github.com/logstash-plugins/logstash-output-tcp/blob/master/lib/logstash/outputs/tcp.rb[tcp],
https://github.com/logstash-plugins/logstash-output-stdout/blob/master/lib/logstash/outputs/stdout.rb[stdout],
and dozens more!

Output plugins do not require you to make use of codecs, but you can use a
codec by including code similar to this:
[source,ruby]
[subs="attributes"]
----------------------------------
  public
  def receive(event)
    return unless output?(event)
    @codec.encode(event)
  end # def receive
----------------------------------

For more examples of output plugins, see the https://github.com/logstash-plugins?query=logstash-output[logstash-plugin github repository].

endif::receive_method[]

// /////////////////////////////////////////////////////////////////////////////
// If teardown_method is defined (should only be for input or output plugin page)
// /////////////////////////////////////////////////////////////////////////////
ifdef::teardown_method[]
==== The `teardown` Method
[source,ruby]
[subs="attributes"]
----------------------------------
  public
  def teardown
    @udp.close if @udp && !@udp.closed?
  end
----------------------------------
The `teardown` method is not present in all input or output plugins.  It is
called when a shutdown happens to ensure that sockets, files, connections and
threads are all closed down properly.  If your plugin uses these connections,
you should include a teardown method.
endif::teardown_method[]

=== add a Gemfile
Gemfiles allow Ruby's Bundler to maintain the dependencies for your plugin.
Currently, all we'll need is the Logstash gem, for testing, but if you require
other gems, you should add them in here. See
http://bundler.io/gemfile.html[Bundler's Gemfile page] for more details.

[source,ruby]
[subs="attributes"]
----------------------------------
source 'https://rubygems.org'
gemspec
gem "logstash", :github => "elasticsearch/logstash", :branch => "{branch}"
----------------------------------

=== add a gemspec file
Gemspecs define the Ruby gem which will be built and contain your plugin. More
information can be found on the
http://guides.rubygems.org/specification-reference/[Rubygems Specification page].

**TBA:** Add details about both runtime & development dependencies.
[source,ruby]
[subs="attributes"]
----------------------------------
Gem::Specification.new do |s|
  s.name = 'logstash-{plugintype}-{pluginname}'
  s.version = '0.1.1'
  s.licenses = ['Apache License (2.0)']
  s.summary = "This filter generates a hello world message in Logstash"
  s.description = "This gem is a logstash plugin required to be installed on top of the Logstash core pipeline using $LS_HOME/bin/plugin install gemname. This gem is not a stand-alone program"
  s.authors = ["Elasticsearch"]
  s.email = 'info@elasticsearch.com'
  s.homepage = "http://www.elasticsearch.org/guide/en/logstash/current/index.html"
  s.require_paths = ["lib"]

  # Files
  s.files = `git ls-files`.split($\)
   # Tests
  s.test_files = s.files.grep(%r{^(test|spec|features)/})

  # Special flag to let us know this is actually a logstash plugin
  s.metadata = { "logstash_plugin" => "true", "logstash_group" => "{plugintype}" }

  # Gem dependencies
  s.add_runtime_dependency 'logstash', '>= 1.4.0', '< 2.0.0'
  s.add_development_dependency 'logstash-devutils'
end
----------------------------------

=== Add Tests
Logstash loves tests. Lots of tests. If you're using this new {plugintype} in a
production environment, you'll want to have some tests to ensure you are not
breaking any existing functionality.

**Note:** A full exposition on RSpec is outside the scope of this document.
Another document will be provided shortly and a link will be provided here.

For help learning about tests and testing, look in the
`spec/pass:attributes[{plugintype}]s/` directory of several other similar
plugins.

=== Clone and test!
Now let's start with a fresh clone of the plugin, build it and run the tests.

[source,sh]
[subs="attributes"]
----------------------------------
git clone git@github.com:gitusername/logstash-{plugintype}-{pluginname}.git
cd logstash-{plugintype}-{pluginname}
----------------------------------

Then, you'll need to install your plugins dependencies with bundler:
[source,sh]
----------------------------------
bundle install
----------------------------------

And finally, run the tests:
[source,sh]
----------------------------------
bundle exec rspec
----------------------------------

You should see a success message, which looks something like this:

[source,sh]
----------------------------------
Finished in 0.034 seconds
1 example, 0 failures
----------------------------------

Hooray! You're almost there! (Unless you saw failures... you should fix those
  first).

=== building the gem and testing via logstash
Now you're ready to build your (well-tested) plugin into a Ruby gem. You already
have all the necessary ingredients, if you've been following along, so let's go
ahead and run the build command:

[source,sh]
[subs="attributes"]
----------------------------------
gem build logstash-{plugintype}-{pluginname}.gemspec
----------------------------------

Download the latest version from the
http://www.elasticsearch.org/overview/logstash/download/[Logstash downloads page].
Untar and cd in to the directory:

[source,sh]
[subs="attributes"]
----------------------------------
curl -O http://download.elasticsearch.org/logstash/logstash/logstash-{ls_version}.tar.gz
tar xzvf logstash-{ls_version}.tar.gz
cd logstash-{ls_version}
----------------------------------

Let's explore the Logstash plugin tool to determine which plugins are currently
available:

[source,sh]
----------------------------------
bin/plugin list
----------------------------------
Depending on the version of Logstash you have installed, you might see a short
or long list of plugins: inputs, codecs, filters and outputs.

Using this plugin too, we can install the gem we just built (use the correct
  path to the gem for your environment):

[source,sh]
[subs="attributes"]
----------------------------------
bin/plugin install /my/logstash/plugins/logstash-{plugintype}-{pluginname}/logstash-{plugintype}-{pluginname}.gem
----------------------------------

After running this, you should see feedback from Logstash that it was
successfully installed:

[source,sh]
[subs="attributes"]
----------------------------------
validating /my/logstash/plugins/logstash-{plugintype}-{pluginname}/logstash-{plugintype}-{pluginname}-0.1.1.gem >= 0
Valid logstash plugin. Continuing...
Successfully installed 'logstash-{plugintype}-{pluginname}' with version '0.1.1'
----------------------------------

Now try running Logstash with a simple configuration passed in via the
command-line, using the `-e` flag.

ifdef::run_method[]
[source,sh]
[subs="attributes"]
----------------------------------
bin/logstash -e 'input { {pluginname}{} } output {stdout { codec => rubydebug }}'
----------------------------------

Type something, in this case "it worked!", and you should see the new message,
"it worked!" output by Logstash:

[source,sh]
[subs="attributes"]
----------------------------------
Using milestone 1 {plugintype} plugin '{pluginname}'. This plugin should work, but would benefit from use by folks like you. Please let us know if you find bugs or have suggestions on how to improve this plugin.  For more information on plugin milestones, see http://logstash.net/docs/{ls_version}/plugin-milestones {:level=>:warn}
change me
{
       "message" => "it worked!",
      "@version" => "1",
    "@timestamp" => "2014-12-17T19:17:44.932Z",
          "host" => "cadenza"
}
----------------------------------
endif::run_method[]

ifdef::encode_method[]
[source,sh]
[subs="attributes"]
----------------------------------
bin/logstash -e 'input { stdin{ codec => {pluginname}{}} } output {stdout { codec => rubydebug }}'
----------------------------------

Type something, in this case "change me", and you should see the new message,
"it worked!" output by Logstash:

[source,sh]
[subs="attributes"]
----------------------------------
Using milestone 1 {plugintype} plugin '{pluginname}'. This plugin should work, but would benefit from use by folks like you. Please let us know if you find bugs or have suggestions on how to improve this plugin.  For more information on plugin milestones, see http://logstash.net/docs/{ls_version}/plugin-milestones {:level=>:warn}
change me
{
       "message" => "TBD TBD TBD",
      "@version" => "1",
    "@timestamp" => "2014-12-17T19:17:44.932Z",
          "host" => "cadenza"
}
----------------------------------
endif::encode_method[]

ifdef::filter_method[]
[source,sh]
[subs="attributes"]
----------------------------------
bin/logstash -e 'input { stdin{} } {plugintype} { {pluginname} { new_message => "it worked!" } } output {stdout { codec => rubydebug }}'
----------------------------------

Type something, in this case "change me", and you should see the new message,
"it worked!" output by Logstash:

[source,sh]
[subs="attributes"]
----------------------------------
Using milestone 1 {plugintype} plugin '{pluginname}'. This plugin should work, but would benefit from use by folks like you. Please let us know if you find bugs or have suggestions on how to improve this plugin.  For more information on plugin milestones, see http://logstash.net/docs/{ls_version}/plugin-milestones {:level=>:warn}
change me
{
       "message" => "it worked!",
      "@version" => "1",
    "@timestamp" => "2014-12-17T19:17:44.932Z",
          "host" => "cadenza"
}
----------------------------------
endif::filter_method[]

ifdef::receive_method[]
TBD
It is harder to display console proof of a working output, unless we're testing
stdout
TBD
endif::receive_method[]

Congratulations! You've built, deployed and successfully run a Logstash
{plugintype}.

=== submitting to rubygems/logstash
TBD.

=== about Logstash documentation

Logstash provides infrastructure to automatically generate documentation for
this plugin. We use the asciidoc format to write documentation so any comments
in the source code will be first converted into asciidoc and then into html. All
plugin documentation is placed under one reference in
http://www.elasticsearch.org/guide/latest/logstash[the Logstash section of the Elasticsearch Guide].

For formatting code or config example, you can use the `asciidoc [source,ruby]`
directive.

For more asciidoc formatting tips, see the excellent reference here
https://github.com/elasticsearch/docs#asciidoc-guide
